<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SAT Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_s_a_t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SAT Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a23fccc2a6f48c849faf8bd5fcbba0140"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#a23fccc2a6f48c849faf8bd5fcbba0140">PolygonPolygonCollision</a> (<a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;polygon1, <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;polygon2)</td></tr>
<tr class="memdesc:a23fccc2a6f48c849faf8bd5fcbba0140"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function takes in two objects that implement the <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> interface, which provides a method to retrieve the vertices of the polygon. The function then calculates all the unique axes of both polygons by performing cross products between the edges of each polygon.  <br /></td></tr>
<tr class="separator:a23fccc2a6f48c849faf8bd5fcbba0140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4886aca7a18adab68091283be0381025"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#a4886aca7a18adab68091283be0381025">CircleCircleCollision</a> (<a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;circle1, <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;circle2)</td></tr>
<tr class="memdesc:a4886aca7a18adab68091283be0381025"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks for collision between two circles by comparing the distance between their centers to the sum of their radii. If the distance is less than the sum of the radii, then the circles are overlapping and there is a collision.  <br /></td></tr>
<tr class="separator:a4886aca7a18adab68091283be0381025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269c80cb179c30e0275d301341799342"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#a269c80cb179c30e0275d301341799342">PolygonCircleCollision</a> (<a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;polygon, <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;circle)</td></tr>
<tr class="memdesc:a269c80cb179c30e0275d301341799342"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks for collision between a circle and a polygon by projecting the circle onto each axis of the polygon and checking for overlap.  <br /></td></tr>
<tr class="separator:a269c80cb179c30e0275d301341799342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedce60e73f8856a41f96b06853d21374"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#aedce60e73f8856a41f96b06853d21374">GetCollisionNormalPolygon</a> (const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;polygon1, const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;polygon2)</td></tr>
<tr class="memdesc:aedce60e73f8856a41f96b06853d21374"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the collision normal between two polygons using the Separating Axis Theorem (<a class="el" href="class_s_a_t.html">SAT</a>) algorithm. The collision normal is the direction in which the polygons are separating, and is used to calculate the collision response (e.g. bouncing off each other).  <br /></td></tr>
<tr class="separator:aedce60e73f8856a41f96b06853d21374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf8a369786ea9c188f4d37fb3345023"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#abdf8a369786ea9c188f4d37fb3345023">GetCollisionNormalCircle</a> (const <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;circle1, const <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;circle2)</td></tr>
<tr class="memdesc:abdf8a369786ea9c188f4d37fb3345023"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the collision normal between two circles using the Separating Axis Theorem (<a class="el" href="class_s_a_t.html">SAT</a>) algorithm. The collision normal is the direction in which the circles are separating, and is used to calculate the collision response (e.g. bouncing off each other).  <br /></td></tr>
<tr class="separator:abdf8a369786ea9c188f4d37fb3345023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f00635c2a2b00a6c82ee468d9d6f0e2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#a3f00635c2a2b00a6c82ee468d9d6f0e2">GetCollisionNormalCirclePolygon</a> (const <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;circle, const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;polygon)</td></tr>
<tr class="memdesc:a3f00635c2a2b00a6c82ee468d9d6f0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the collision normal between a circle and a polygon using the Separating Axis Theorem (<a class="el" href="class_s_a_t.html">SAT</a>) algorithm. The collision normal is the direction in which the circle and polygon are separating, and is used to calculate the collision response. NOT CURRENTLY WORKING!  <br /></td></tr>
<tr class="separator:a3f00635c2a2b00a6c82ee468d9d6f0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32a9de78e2294080e5af54899c49454"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#ac32a9de78e2294080e5af54899c49454">GetOverlapPolygon</a> (const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;polygon1, const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;polygon2, const <a class="el" href="class_vector2.html">Vector2</a> &amp;axis)</td></tr>
<tr class="memdesc:ac32a9de78e2294080e5af54899c49454"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the overlap between two polygons along a given axis.  <br /></td></tr>
<tr class="separator:ac32a9de78e2294080e5af54899c49454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3084050f2f777e9e8e5f43126a923ea3"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#a3084050f2f777e9e8e5f43126a923ea3">GetOverlapCirclePolygon</a> (const <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;circle, const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;polygon, const <a class="el" href="class_vector2.html">Vector2</a> &amp;axis)</td></tr>
<tr class="memdesc:a3084050f2f777e9e8e5f43126a923ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the overlap between a circle and a polygon projected onto a given axis. It takes in two arguments - an object that implements the <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> interface and an object that implements the <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> interface, as well as a <a class="el" href="class_vector2.html">Vector2</a> axis to project onto. The function returns a float representing the overlap amount between the circle and polygon projections. NOT CURRENTLY WORKING!  <br /></td></tr>
<tr class="separator:a3084050f2f777e9e8e5f43126a923ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78280c2e8749bb7fdf17e95e3c44086"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#ac78280c2e8749bb7fdf17e95e3c44086">ProjectOntoAxis</a> (const <a class="el" href="class_vector2.html">Vector2</a> &amp;axis, const std::vector&lt; <a class="el" href="class_vector2.html">Vector2</a> &gt; &amp;vertices, float &amp;min, float &amp;max)</td></tr>
<tr class="memdesc:ac78280c2e8749bb7fdf17e95e3c44086"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function projects a set of vertices onto a given axis and returns the minimum and maximum values of the resulting projections.  <br /></td></tr>
<tr class="separator:ac78280c2e8749bb7fdf17e95e3c44086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeb1d1e41fb6914e6cbd6e031263f9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_a_t.html#a1eeb1d1e41fb6914e6cbd6e031263f9b">GetUniqueAxes</a> (const std::vector&lt; <a class="el" href="class_vector2.html">Vector2</a> &gt; &amp;vertices, std::vector&lt; <a class="el" href="class_vector2.html">Vector2</a> &gt; &amp;axes)</td></tr>
<tr class="memdesc:a1eeb1d1e41fb6914e6cbd6e031263f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates unique axes from a list of vertices of a convex polygon. It takes in two parameters: a vector of vertices and a reference to a vector of axes. The function iterates over each vertex of the polygon, calculates the normal vector of the edge between the current vertex and the next vertex, and checks if the normal is unique by comparing it to the existing axes in the axes vector. If the normal is unique, it is added to the axes vector. At the end of the function, the axes vector contains all the unique axes of the polygon.  <br /></td></tr>
<tr class="separator:a1eeb1d1e41fb6914e6cbd6e031263f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e84a48ba67e0f6917791b8860cb6aee"><td class="memItemLeft" align="right" valign="top"><a id="a9e84a48ba67e0f6917791b8860cb6aee" name="a9e84a48ba67e0f6917791b8860cb6aee"></a>
static float&#160;</td><td class="memItemRight" valign="bottom"><b>DotProduct</b> (const <a class="el" href="class_vector2.html">Vector2</a> &amp;a, const <a class="el" href="class_vector2.html">Vector2</a> &amp;b)</td></tr>
<tr class="separator:a9e84a48ba67e0f6917791b8860cb6aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42da1515c3ee7d95c5cc6f1f44e354b"><td class="memItemLeft" align="right" valign="top"><a id="af42da1515c3ee7d95c5cc6f1f44e354b" name="af42da1515c3ee7d95c5cc6f1f44e354b"></a>
static <a class="el" href="class_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Perpendicular</b> (const <a class="el" href="class_vector2.html">Vector2</a> &amp;v1, const <a class="el" href="class_vector2.html">Vector2</a> &amp;v2)</td></tr>
<tr class="separator:af42da1515c3ee7d95c5cc6f1f44e354b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4886aca7a18adab68091283be0381025" name="a4886aca7a18adab68091283be0381025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4886aca7a18adab68091283be0381025">&#9670;&#160;</a></span>CircleCircleCollision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SAT::CircleCircleCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>circle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>circle2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks for collision between two circles by comparing the distance between their centers to the sum of their radii. If the distance is less than the sum of the radii, then the circles are overlapping and there is a collision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circle1</td><td></td></tr>
    <tr><td class="paramname">circle2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="abdf8a369786ea9c188f4d37fb3345023" name="abdf8a369786ea9c188f4d37fb3345023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf8a369786ea9c188f4d37fb3345023">&#9670;&#160;</a></span>GetCollisionNormalCircle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector2.html">Vector2</a> SAT::GetCollisionNormalCircle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>circle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>circle2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the collision normal between two circles using the Separating Axis Theorem (<a class="el" href="class_s_a_t.html">SAT</a>) algorithm. The collision normal is the direction in which the circles are separating, and is used to calculate the collision response (e.g. bouncing off each other). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circle1</td><td></td></tr>
    <tr><td class="paramname">circle2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3f00635c2a2b00a6c82ee468d9d6f0e2" name="a3f00635c2a2b00a6c82ee468d9d6f0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f00635c2a2b00a6c82ee468d9d6f0e2">&#9670;&#160;</a></span>GetCollisionNormalCirclePolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector2.html">Vector2</a> SAT::GetCollisionNormalCirclePolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the collision normal between a circle and a polygon using the Separating Axis Theorem (<a class="el" href="class_s_a_t.html">SAT</a>) algorithm. The collision normal is the direction in which the circle and polygon are separating, and is used to calculate the collision response. NOT CURRENTLY WORKING! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circle</td><td></td></tr>
    <tr><td class="paramname">polygon</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aedce60e73f8856a41f96b06853d21374" name="aedce60e73f8856a41f96b06853d21374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedce60e73f8856a41f96b06853d21374">&#9670;&#160;</a></span>GetCollisionNormalPolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector2.html">Vector2</a> SAT::GetCollisionNormalPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the collision normal between two polygons using the Separating Axis Theorem (<a class="el" href="class_s_a_t.html">SAT</a>) algorithm. The collision normal is the direction in which the polygons are separating, and is used to calculate the collision response (e.g. bouncing off each other). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon1</td><td></td></tr>
    <tr><td class="paramname">polygon2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3084050f2f777e9e8e5f43126a923ea3" name="a3084050f2f777e9e8e5f43126a923ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3084050f2f777e9e8e5f43126a923ea3">&#9670;&#160;</a></span>GetOverlapCirclePolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SAT::GetOverlapCirclePolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the overlap between a circle and a polygon projected onto a given axis. It takes in two arguments - an object that implements the <a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> interface and an object that implements the <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> interface, as well as a <a class="el" href="class_vector2.html">Vector2</a> axis to project onto. The function returns a float representing the overlap amount between the circle and polygon projections. NOT CURRENTLY WORKING! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circle</td><td></td></tr>
    <tr><td class="paramname">polygon</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac32a9de78e2294080e5af54899c49454" name="ac32a9de78e2294080e5af54899c49454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32a9de78e2294080e5af54899c49454">&#9670;&#160;</a></span>GetOverlapPolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SAT::GetOverlapPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the overlap between two polygons along a given axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon1</td><td></td></tr>
    <tr><td class="paramname">polygon2</td><td></td></tr>
    <tr><td class="paramname">axis</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1eeb1d1e41fb6914e6cbd6e031263f9b" name="a1eeb1d1e41fb6914e6cbd6e031263f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeb1d1e41fb6914e6cbd6e031263f9b">&#9670;&#160;</a></span>GetUniqueAxes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAT::GetUniqueAxes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_vector2.html">Vector2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vector2.html">Vector2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates unique axes from a list of vertices of a convex polygon. It takes in two parameters: a vector of vertices and a reference to a vector of axes. The function iterates over each vertex of the polygon, calculates the normal vector of the edge between the current vertex and the next vertex, and checks if the normal is unique by comparing it to the existing axes in the axes vector. If the normal is unique, it is added to the axes vector. At the end of the function, the axes vector contains all the unique axes of the polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td></td></tr>
    <tr><td class="paramname">axes</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a269c80cb179c30e0275d301341799342" name="a269c80cb179c30e0275d301341799342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269c80cb179c30e0275d301341799342">&#9670;&#160;</a></span>PolygonCircleCollision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SAT::PolygonCircleCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_circle_collidable.html">ICircleCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>circle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks for collision between a circle and a polygon by projecting the circle onto each axis of the polygon and checking for overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td></td></tr>
    <tr><td class="paramname">circle</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a23fccc2a6f48c849faf8bd5fcbba0140" name="a23fccc2a6f48c849faf8bd5fcbba0140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fccc2a6f48c849faf8bd5fcbba0140">&#9670;&#160;</a></span>PolygonPolygonCollision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SAT::PolygonPolygonCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function takes in two objects that implement the <a class="el" href="class_i_polygon_collidable.html">IPolygonCollidable</a> interface, which provides a method to retrieve the vertices of the polygon. The function then calculates all the unique axes of both polygons by performing cross products between the edges of each polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon1</td><td></td></tr>
    <tr><td class="paramname">polygon2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac78280c2e8749bb7fdf17e95e3c44086" name="ac78280c2e8749bb7fdf17e95e3c44086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78280c2e8749bb7fdf17e95e3c44086">&#9670;&#160;</a></span>ProjectOntoAxis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SAT::ProjectOntoAxis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_vector2.html">Vector2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function projects a set of vertices onto a given axis and returns the minimum and maximum values of the resulting projections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td></td></tr>
    <tr><td class="paramname">vertices</td><td></td></tr>
    <tr><td class="paramname">min</td><td></td></tr>
    <tr><td class="paramname">max</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_s_a_t_8h_source.html">SAT.h</a></li>
<li>SAT.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
